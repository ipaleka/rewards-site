#pragma version 11
#pragma typetrack false

// algopy.arc4.ARC4Contract.approval_program() -> uint64:
main:
    intcblock 0 1 8 4
    bytecblock "token_id" "admin_address" "allocations" "claim_period_duration"
    // contract.py:26
    // class Airdrop(arc4.ARC4Contract):
    txn NumAppArgs
    bz main_create_application@13
    txn OnCompletion
    !
    assert // OnCompletion must be NoOp
    txn ApplicationID
    assert
    pushbytess 0xb6e5a0e5 0xa7e93504 0xf1577726 0x97892c81 // method "setup(uint64,uint64)void", method "add_allocations(address[],uint64[])void", method "claim()void", method "reclaim_allocation(address)void"
    txna ApplicationArgs 0
    match setup add_allocations claim reclaim_allocation
    err

main_create_application@13:
    // contract.py:58
    // @arc4.baremethod(allow_actions=["NoOp"], create="require")
    txn OnCompletion
    !
    txn ApplicationID
    !
    &&
    assert // OnCompletion must be NoOp && can only call when creating
    // contract.py:65
    // self.admin_address.value = Txn.sender
    bytec_1 // "admin_address"
    txn Sender
    app_global_put
    // contract.py:58
    // @arc4.baremethod(allow_actions=["NoOp"], create="require")
    intc_1 // 1
    return


// airdrop.contract.Airdrop.setup[routing]() -> void:
setup:
    // contract.py:67
    // @arc4.abimethod
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    // contract.py:79
    // assert Txn.sender == self.admin_address.value, "Sender is not the admin"
    txn Sender
    intc_0 // 0
    bytec_1 // "admin_address"
    app_global_get_ex
    assert // check self.admin_address exists
    ==
    assert // Sender is not the admin
    // contract.py:80
    // assert self.token_id.value.id == 0, "Contract already set up"
    intc_0 // 0
    bytec_0 // "token_id"
    app_global_get_ex
    assert // check self.token_id exists
    !
    assert // Contract already set up
    // contract.py:81
    // self.token_id.value = token_id
    bytec_0 // "token_id"
    uncover 2
    app_global_put
    // contract.py:82
    // self.claim_period_duration.value = claim_period_duration
    bytec_3 // "claim_period_duration"
    swap
    app_global_put
    // contract.py:84-89
    // # Contract opts-in to the ASA
    // itxn.AssetTransfer(
    //     xfer_asset=self.token_id.value,
    //     asset_receiver=Global.current_application_address,
    //     asset_amount=0,
    // ).submit()
    itxn_begin
    // contract.py:86
    // xfer_asset=self.token_id.value,
    intc_0 // 0
    bytec_0 // "token_id"
    app_global_get_ex
    assert // check self.token_id exists
    // contract.py:87
    // asset_receiver=Global.current_application_address,
    global CurrentApplicationAddress
    // contract.py:88
    // asset_amount=0,
    intc_0 // 0
    itxn_field AssetAmount
    itxn_field AssetReceiver
    itxn_field XferAsset
    // contract.py:84-85
    // # Contract opts-in to the ASA
    // itxn.AssetTransfer(
    intc_3 // axfer
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // contract.py:84-89
    // # Contract opts-in to the ASA
    // itxn.AssetTransfer(
    //     xfer_asset=self.token_id.value,
    //     asset_receiver=Global.current_application_address,
    //     asset_amount=0,
    // ).submit()
    itxn_submit
    // contract.py:67
    // @arc4.abimethod
    intc_1 // 1
    return


// airdrop.contract.Airdrop.add_allocations[routing]() -> void:
add_allocations:
    // contract.py:91
    // @arc4.abimethod
    txna ApplicationArgs 1
    dupn 2
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    dup
    cover 2
    dup
    pushint 32 // 32
    *
    pushint 2 // 2
    +
    uncover 2
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.static_array<arc4.uint8, 32>>
    txna ApplicationArgs 2
    dup
    cover 2
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    dup
    intc_2 // 8
    *
    pushint 2 // 2
    +
    uncover 2
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint64>
    // contract.py:107
    // assert Txn.sender == self.admin_address.value, "Sender is not the admin"
    txn Sender
    intc_0 // 0
    bytec_1 // "admin_address"
    app_global_get_ex
    assert // check self.admin_address exists
    ==
    assert // Sender is not the admin
    // contract.py:109
    // addresses.length == amounts.length
    ==
    // contract.py:108-110
    // assert (
    //     addresses.length == amounts.length
    // ), "Input arrays must have the same length"
    assert // Input arrays must have the same length
    // contract.py:112
    // expires_at = Global.latest_timestamp + self.claim_period_duration.value
    global LatestTimestamp
    intc_0 // 0
    bytec_3 // "claim_period_duration"
    app_global_get_ex
    assert // check self.claim_period_duration exists
    +
    // contract.py:113
    // for i in urange(addresses.length):
    intc_0 // 0

add_allocations_for_header@2:
    // contract.py:113
    // for i in urange(addresses.length):
    dup
    dig 4
    <
    bz add_allocations_after_for@8
    // contract.py:114
    // address = addresses[i].native
    dig 4
    extract 2 0
    dig 1
    dup
    cover 2
    pushint 32 // 32
    *
    pushint 32 // 32
    extract3 // on error: index access is out of bounds
    // contract.py:115
    // amount = amounts[i].native
    dig 4
    extract 2 0
    uncover 2
    intc_2 // 8
    *
    extract_uint64
    swap
    // contract.py:116
    // allocation_box = self.allocations.box(address)
    bytec_2 // "allocations"
    swap
    concat
    dup
    cover 2
    // contract.py:117
    // if allocation_box:
    box_len
    bury 1
    bz add_allocations_else_body@5
    // contract.py:118-119
    // # Update existing allocation
    // existing_allocation = allocation_box.value.copy()
    swap
    dup
    box_get
    assert // check Box exists
    // contract.py:120
    // existing_allocation.amount += amount
    dup
    intc_0 // 0
    extract_uint64
    uncover 3
    +
    itob
    replace2 0
    // contract.py:121
    // existing_allocation.expires_at = expires_at
    dig 3
    itob
    replace2 8
    // contract.py:122
    // allocation_box.value = existing_allocation.copy()
    box_put

add_allocations_after_if_else@6:
    // contract.py:113
    // for i in urange(addresses.length):
    dup
    intc_1 // 1
    +
    bury 1
    b add_allocations_for_header@2

add_allocations_else_body@5:
    // contract.py:125-126
    // # Create new allocation
    // assert allocation_box.create()
    swap
    dup
    pushint 16 // 16
    box_create
    assert
    // contract.py:127
    // allocation_box.value = Allocation(amount=amount, expires_at=expires_at)
    swap
    itob
    dig 3
    itob
    concat
    box_put
    b add_allocations_after_if_else@6

add_allocations_after_for@8:
    // contract.py:91
    // @arc4.abimethod
    intc_1 // 1
    return


// airdrop.contract.Airdrop.claim[routing]() -> void:
claim:
    // contract.py:138
    // sender = Txn.sender
    txn Sender
    dup
    // contract.py:139
    // allocation_box = self.allocations.box(sender)
    bytec_2 // "allocations"
    dig 1
    concat
    dup
    cover 2
    // contract.py:140
    // assert allocation_box, "Sender has no allocation"
    dup
    box_len
    bury 1
    assert // Sender has no allocation
    // contract.py:141
    // amount_to_claim = allocation_box.value.amount
    box_get
    pop
    intc_0 // 0
    extract_uint64
    swap
    // contract.py:145
    // sender, self.token_id.value.id
    intc_0 // 0
    bytec_0 // "token_id"
    app_global_get_ex
    assert // check self.token_id exists
    // contract.py:143-146
    // # Check if the user is already opted-in to the asset
    // balance, opted_in = op.AssetHoldingGet.asset_balance(
    //     sender, self.token_id.value.id
    // )
    asset_holding_get AssetBalance
    bury 1
    // contract.py:148
    // if not opted_in:
    bnz claim_after_if_else@4
    // contract.py:149-154
    // # Create an opt-in transaction for the user
    // itxn.AssetTransfer(
    //     xfer_asset=self.token_id.value,
    //     asset_receiver=sender,
    //     asset_amount=0,
    // ).submit()
    itxn_begin
    // contract.py:151
    // xfer_asset=self.token_id.value,
    intc_0 // 0
    bytec_0 // "token_id"
    app_global_get_ex
    assert // check self.token_id exists
    // contract.py:153
    // asset_amount=0,
    intc_0 // 0
    itxn_field AssetAmount
    dig 3
    itxn_field AssetReceiver
    itxn_field XferAsset
    // contract.py:149-150
    // # Create an opt-in transaction for the user
    // itxn.AssetTransfer(
    intc_3 // axfer
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // contract.py:149-154
    // # Create an opt-in transaction for the user
    // itxn.AssetTransfer(
    //     xfer_asset=self.token_id.value,
    //     asset_receiver=sender,
    //     asset_amount=0,
    // ).submit()
    itxn_submit

claim_after_if_else@4:
    // contract.py:156-161
    // # Create the transaction to transfer the allocated amount
    // itxn.AssetTransfer(
    //     xfer_asset=self.token_id.value,
    //     asset_receiver=sender,
    //     asset_amount=amount_to_claim,
    // ).submit()
    itxn_begin
    // contract.py:158
    // xfer_asset=self.token_id.value,
    intc_0 // 0
    bytec_0 // "token_id"
    app_global_get_ex
    assert // check self.token_id exists
    dig 1
    itxn_field AssetAmount
    dig 3
    itxn_field AssetReceiver
    itxn_field XferAsset
    // contract.py:156-157
    // # Create the transaction to transfer the allocated amount
    // itxn.AssetTransfer(
    intc_3 // axfer
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // contract.py:156-161
    // # Create the transaction to transfer the allocated amount
    // itxn.AssetTransfer(
    //     xfer_asset=self.token_id.value,
    //     asset_receiver=sender,
    //     asset_amount=amount_to_claim,
    // ).submit()
    itxn_submit
    // contract.py:163-164
    // # Delete the allocation to prevent claiming again
    // del allocation_box.value
    dig 1
    box_del
    pop
    // contract.py:129
    // @arc4.abimethod(name="claim")
    intc_1 // 1
    return


// airdrop.contract.Airdrop.reclaim_allocation[routing]() -> void:
reclaim_allocation:
    // contract.py:166
    // @arc4.abimethod
    txna ApplicationArgs 1
    dup
    len
    pushint 32 // 32
    ==
    assert // invalid number of bytes for arc4.static_array<arc4.uint8, 32>
    // contract.py:174
    // assert Txn.sender == self.admin_address.value, "Sender is not the admin"
    txn Sender
    intc_0 // 0
    bytec_1 // "admin_address"
    app_global_get_ex
    assert // check self.admin_address exists
    swap
    dig 1
    ==
    assert // Sender is not the admin
    // contract.py:175
    // allocation_box = self.allocations.box(user_address)
    bytec_2 // "allocations"
    uncover 2
    concat
    // contract.py:176
    // assert allocation_box, "User has no allocation"
    dup
    box_len
    bury 1
    assert // User has no allocation
    // contract.py:177
    // allocation = allocation_box.value.copy()
    dup
    box_get
    pop
    // contract.py:179
    // Global.latest_timestamp > allocation.expires_at
    global LatestTimestamp
    dig 1
    intc_2 // 8
    extract_uint64
    >
    // contract.py:178-180
    // assert (
    //     Global.latest_timestamp > allocation.expires_at
    // ), "Claim period has not ended for this user"
    assert // Claim period has not ended for this user
    // contract.py:182-187
    // # Transfer the user's allocated amount back to the admin
    // itxn.AssetTransfer(
    //     xfer_asset=self.token_id.value,
    //     asset_receiver=self.admin_address.value,
    //     asset_amount=allocation.amount,
    // ).submit()
    itxn_begin
    // contract.py:184
    // xfer_asset=self.token_id.value,
    intc_0 // 0
    bytec_0 // "token_id"
    app_global_get_ex
    assert // check self.token_id exists
    // contract.py:186
    // asset_amount=allocation.amount,
    swap
    intc_0 // 0
    extract_uint64
    itxn_field AssetAmount
    uncover 2
    itxn_field AssetReceiver
    itxn_field XferAsset
    // contract.py:182-183
    // # Transfer the user's allocated amount back to the admin
    // itxn.AssetTransfer(
    intc_3 // axfer
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // contract.py:182-187
    // # Transfer the user's allocated amount back to the admin
    // itxn.AssetTransfer(
    //     xfer_asset=self.token_id.value,
    //     asset_receiver=self.admin_address.value,
    //     asset_amount=allocation.amount,
    // ).submit()
    itxn_submit
    // contract.py:189-190
    // # Delete the allocation
    // del allocation_box.value
    box_del
    pop
    // contract.py:166
    // @arc4.abimethod
    intc_1 // 1
    return
