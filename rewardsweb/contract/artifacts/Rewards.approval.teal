#pragma version 11
#pragma typetrack false

// algopy.arc4.ARC4Contract.approval_program() -> uint64:
main:
    intcblock 0 1 8 4
    bytecblock "token_id" "admin_address" "claim_period_duration" "allocations"
    // contract/contract.py:27
    // class Rewards(arc4.ARC4Contract):
    txn NumAppArgs
    bz main_bare_routing@13
    txn OnCompletion
    !
    assert // OnCompletion must be NoOp
    txn ApplicationID
    assert
    pushbytess 0xb6e5a0e5 0xa7e93504 0xf1577726 0x97892c81 // method "setup(uint64,uint64)void", method "add_allocations(address[],uint64[])void", method "claim()void", method "reclaim_allocation(address)void"
    txna ApplicationArgs 0
    match setup add_allocations claim reclaim_allocation
    err

main_bare_routing@13:
    // contract/contract.py:27
    // class Rewards(arc4.ARC4Contract):
    intc_0 // NoOp
    pushint 5 // DeleteApplication
    txn OnCompletion
    match main_create_application@14 main_delete_application@15
    err

main_delete_application@15:
    // contract/contract.py:70
    // @arc4.baremethod(allow_actions=["DeleteApplication"])
    txn ApplicationID
    assert // can only call when not creating
    // contract/contract.py:75
    // assert Txn.sender == self.admin_address.value, "Sender is not the admin"
    txn Sender
    intc_0 // 0
    bytec_1 // "admin_address"
    app_global_get_ex
    assert // check self.admin_address exists
    ==
    assert // Sender is not the admin
    // contract/contract.py:70
    // @arc4.baremethod(allow_actions=["DeleteApplication"])
    intc_1 // 1
    return

main_create_application@14:
    // contract/contract.py:59
    // @arc4.baremethod(allow_actions=["NoOp"], create="require")
    txn ApplicationID
    !
    assert // can only call when creating
    // contract/contract.py:66
    // self.admin_address.value = Txn.sender
    bytec_1 // "admin_address"
    txn Sender
    app_global_put
    // contract/contract.py:67
    // self.token_id.value = UInt64(0)
    bytec_0 // "token_id"
    intc_0 // 0
    app_global_put
    // contract/contract.py:68
    // self.claim_period_duration.value = UInt64(0)
    bytec_2 // "claim_period_duration"
    intc_0 // 0
    app_global_put
    // contract/contract.py:59
    // @arc4.baremethod(allow_actions=["NoOp"], create="require")
    intc_1 // 1
    return


// contract.contract.Rewards.setup[routing]() -> void:
setup:
    // contract/contract.py:77
    // @arc4.abimethod
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    // contract/contract.py:89
    // assert Txn.sender == self.admin_address.value, "Sender is not the admin"
    txn Sender
    intc_0 // 0
    bytec_1 // "admin_address"
    app_global_get_ex
    assert // check self.admin_address exists
    ==
    assert // Sender is not the admin
    // contract/contract.py:90
    // assert self.token_id.value == 0, "Contract already set up"
    intc_0 // 0
    bytec_0 // "token_id"
    app_global_get_ex
    assert // check self.token_id exists
    !
    assert // Contract already set up
    // contract/contract.py:91
    // self.token_id.value = token.id
    bytec_0 // "token_id"
    uncover 2
    app_global_put
    // contract/contract.py:92
    // self.claim_period_duration.value = claim_period_duration
    bytec_2 // "claim_period_duration"
    swap
    app_global_put
    // contract/contract.py:94-99
    // # Contract opts-in to the ASA
    // itxn.AssetTransfer(
    //     xfer_asset=self.token_id.value,
    //     asset_receiver=Global.current_application_address,
    //     asset_amount=0,
    // ).submit()
    itxn_begin
    // contract/contract.py:96
    // xfer_asset=self.token_id.value,
    intc_0 // 0
    bytec_0 // "token_id"
    app_global_get_ex
    assert // check self.token_id exists
    // contract/contract.py:97
    // asset_receiver=Global.current_application_address,
    global CurrentApplicationAddress
    // contract/contract.py:98
    // asset_amount=0,
    intc_0 // 0
    itxn_field AssetAmount
    itxn_field AssetReceiver
    itxn_field XferAsset
    // contract/contract.py:94-95
    // # Contract opts-in to the ASA
    // itxn.AssetTransfer(
    intc_3 // axfer
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // contract/contract.py:94-99
    // # Contract opts-in to the ASA
    // itxn.AssetTransfer(
    //     xfer_asset=self.token_id.value,
    //     asset_receiver=Global.current_application_address,
    //     asset_amount=0,
    // ).submit()
    itxn_submit
    // contract/contract.py:77
    // @arc4.abimethod
    intc_1 // 1
    return


// contract.contract.Rewards.add_allocations[routing]() -> void:
add_allocations:
    pushbytes ""
    dupn 3
    // contract/contract.py:101
    // @arc4.abimethod
    txna ApplicationArgs 1
    dupn 2
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    dup
    cover 2
    dup
    pushint 32 // 32
    *
    pushint 2 // 2
    +
    uncover 2
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.static_array<arc4.uint8, 32>>
    txna ApplicationArgs 2
    dup
    cover 2
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    dup
    intc_2 // 8
    *
    pushint 2 // 2
    +
    uncover 2
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint64>
    // contract/contract.py:117
    // assert Txn.sender == self.admin_address.value, "Sender is not the admin"
    txn Sender
    intc_0 // 0
    bytec_1 // "admin_address"
    app_global_get_ex
    assert // check self.admin_address exists
    ==
    assert // Sender is not the admin
    // contract/contract.py:119
    // addresses.length == amounts.length
    ==
    // contract/contract.py:118-120
    // assert (
    //     addresses.length == amounts.length
    // ), "Input arrays must have the same length"
    assert // Input arrays must have the same length
    // contract/contract.py:122
    // required_funding = UInt64(0)
    intc_0 // 0
    // contract/contract.py:123
    // for j in urange(addresses.length):
    dup

add_allocations_for_header@2:
    // contract/contract.py:123
    // for j in urange(addresses.length):
    dup
    dig 4
    <
    bz add_allocations_after_for@5
    // contract/contract.py:124
    // required_funding += amounts[j].as_uint64()
    dig 2
    extract 2 0
    dig 1
    dup
    cover 2
    intc_2 // 8
    *
    extract_uint64
    dig 3
    +
    bury 3
    // contract/contract.py:123
    // for j in urange(addresses.length):
    intc_1 // 1
    +
    bury 1
    b add_allocations_for_header@2

add_allocations_after_for@5:
    // contract/contract.py:126
    // funded = False
    intc_0 // 0
    bury 8
    // contract/contract.py:128
    // assert op.Global.group_size >= UInt64(2), "Missing funding transaction in group"
    global GroupSize
    pushint 2 // 2
    >=
    assert // Missing funding transaction in group
    // contract/contract.py:130
    // for i in urange(op.Global.group_size):
    global GroupSize
    bury 6
    intc_0 // 0
    bury 7

add_allocations_for_header@6:
    // contract/contract.py:130
    // for i in urange(op.Global.group_size):
    dig 6
    dig 6
    <
    bz add_allocations_after_for@15
    // contract/contract.py:131
    // if op.GTxn.type_enum(i) == TransactionType.AssetTransfer:
    dig 6
    gtxns TypeEnum
    intc_3 // axfer
    ==
    bz add_allocations_after_if_else@13
    // contract/contract.py:132
    // if op.GTxn.xfer_asset(i).id == self.token_id.value:
    dig 6
    gtxns XferAsset
    intc_0 // 0
    bytec_0 // "token_id"
    app_global_get_ex
    assert // check self.token_id exists
    ==
    bz add_allocations_after_if_else@13
    // contract/contract.py:133
    // if op.GTxn.asset_receiver(i) == Global.current_application_address:
    dig 6
    gtxns AssetReceiver
    global CurrentApplicationAddress
    ==
    bz add_allocations_after_if_else@13
    // contract/contract.py:135
    // op.GTxn.amount(i) == required_funding
    dig 6
    gtxns Amount
    dig 2
    ==
    // contract/contract.py:134-136
    // assert (
    //     op.GTxn.amount(i) == required_funding
    // ), "Incorrect ASA funding"
    assert // Incorrect ASA funding
    // contract/contract.py:137
    // funded = True
    intc_1 // 1
    bury 8

add_allocations_after_if_else@13:
    // contract/contract.py:130
    // for i in urange(op.Global.group_size):
    dig 6
    intc_1 // 1
    +
    bury 7
    b add_allocations_for_header@6

add_allocations_after_for@15:
    // contract/contract.py:139
    // assert funded, "ASA funding transaction missing"
    dig 7
    assert // ASA funding transaction missing
    // contract/contract.py:141
    // expires_at = Global.latest_timestamp + self.claim_period_duration.value
    global LatestTimestamp
    intc_0 // 0
    bytec_2 // "claim_period_duration"
    app_global_get_ex
    assert // check self.claim_period_duration exists
    +
    bury 9
    // contract/contract.py:142
    // for i in urange(addresses.length):
    intc_0 // 0
    bury 7

add_allocations_for_header@16:
    // contract/contract.py:142
    // for i in urange(addresses.length):
    dig 6
    dig 4
    <
    bz add_allocations_after_for@22
    // contract/contract.py:143
    // address = addresses[i].native
    dig 4
    extract 2 0
    dig 7
    dup
    cover 2
    pushint 32 // 32
    *
    pushint 32 // 32
    extract3 // on error: index access is out of bounds
    // contract/contract.py:144
    // amount = amounts[i].as_uint64()
    dig 4
    extract 2 0
    uncover 2
    intc_2 // 8
    *
    extract_uint64
    swap
    // contract/contract.py:145
    // allocation_box = self.allocations.box(address)
    bytec_3 // "allocations"
    swap
    concat
    dup
    cover 2
    // contract/contract.py:146
    // if allocation_box:
    box_len
    bury 1
    bz add_allocations_else_body@19
    // contract/contract.py:147-148
    // # Update existing allocation
    // existing_allocation = allocation_box.value.copy()
    swap
    dup
    box_get
    assert // check Box exists
    // contract/contract.py:149
    // existing_allocation.amount += amount
    dup
    intc_0 // 0
    extract_uint64
    uncover 3
    +
    itob
    replace2 0
    // contract/contract.py:150
    // existing_allocation.expires_at = expires_at
    dig 10
    itob
    replace2 8
    // contract/contract.py:151
    // allocation_box.value = existing_allocation.copy()
    box_put

add_allocations_after_if_else@20:
    // contract/contract.py:142
    // for i in urange(addresses.length):
    dig 6
    intc_1 // 1
    +
    bury 7
    b add_allocations_for_header@16

add_allocations_else_body@19:
    // contract/contract.py:154-155
    // # Create new allocation
    // assert allocation_box.create()
    swap
    dup
    pushint 16 // 16
    box_create
    assert
    // contract/contract.py:156
    // allocation_box.value = Allocation(amount=amount, expires_at=expires_at)
    swap
    itob
    dig 10
    itob
    concat
    box_put
    b add_allocations_after_if_else@20

add_allocations_after_for@22:
    // contract/contract.py:101
    // @arc4.abimethod
    intc_1 // 1
    return


// contract.contract.Rewards.claim[routing]() -> void:
claim:
    // contract/contract.py:167
    // sender = Txn.sender
    txn Sender
    // contract/contract.py:168
    // allocation_box = self.allocations.box(sender)
    bytec_3 // "allocations"
    dig 1
    concat
    // contract/contract.py:169
    // assert allocation_box, "Sender has no allocation"
    dup
    box_len
    bury 1
    assert // Sender has no allocation
    // contract/contract.py:171
    // allocation = allocation_box.value.copy()
    dup
    box_get
    pop
    // contract/contract.py:173
    // Global.latest_timestamp <= allocation.expires_at
    global LatestTimestamp
    dig 1
    intc_2 // 8
    extract_uint64
    <=
    // contract/contract.py:172-174
    // assert (
    //     Global.latest_timestamp <= allocation.expires_at
    // ), "Claim period has ended"
    assert // Claim period has ended
    // contract/contract.py:176
    // amount_to_claim = allocation.amount
    intc_0 // 0
    extract_uint64
    // contract/contract.py:180
    // sender, self.token_id.value
    intc_0 // 0
    bytec_0 // "token_id"
    app_global_get_ex
    assert // check self.token_id exists
    // contract/contract.py:178-181
    // # Check if the user is already opted-in to the asset
    // balance, opted_in = op.AssetHoldingGet.asset_balance(
    //     sender, self.token_id.value
    // )
    dig 3
    dig 1
    asset_holding_get AssetBalance
    bury 1
    // contract/contract.py:182
    // assert opted_in, "Sender has not opted-in to the asset"
    assert // Sender has not opted-in to the asset
    // contract/contract.py:184-189
    // # Create the transaction to transfer the allocated amount
    // itxn.AssetTransfer(
    //     xfer_asset=self.token_id.value,
    //     asset_receiver=sender,
    //     asset_amount=amount_to_claim,
    // ).submit()
    itxn_begin
    swap
    itxn_field AssetAmount
    uncover 2
    itxn_field AssetReceiver
    itxn_field XferAsset
    // contract/contract.py:184-185
    // # Create the transaction to transfer the allocated amount
    // itxn.AssetTransfer(
    intc_3 // axfer
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // contract/contract.py:184-189
    // # Create the transaction to transfer the allocated amount
    // itxn.AssetTransfer(
    //     xfer_asset=self.token_id.value,
    //     asset_receiver=sender,
    //     asset_amount=amount_to_claim,
    // ).submit()
    itxn_submit
    // contract/contract.py:191-192
    // # Delete the allocation to prevent claiming again
    // del allocation_box.value
    box_del
    pop
    // contract/contract.py:158
    // @arc4.abimethod(name="claim")
    intc_1 // 1
    return


// contract.contract.Rewards.reclaim_allocation[routing]() -> void:
reclaim_allocation:
    // contract/contract.py:194
    // @arc4.abimethod
    txna ApplicationArgs 1
    dup
    len
    pushint 32 // 32
    ==
    assert // invalid number of bytes for arc4.static_array<arc4.uint8, 32>
    // contract/contract.py:202
    // assert Txn.sender == self.admin_address.value, "Sender is not the admin"
    txn Sender
    intc_0 // 0
    bytec_1 // "admin_address"
    app_global_get_ex
    assert // check self.admin_address exists
    swap
    dig 1
    ==
    assert // Sender is not the admin
    // contract/contract.py:203
    // allocation_box = self.allocations.box(user_address)
    bytec_3 // "allocations"
    uncover 2
    concat
    // contract/contract.py:204
    // assert allocation_box, "User has no allocation"
    dup
    box_len
    bury 1
    assert // User has no allocation
    // contract/contract.py:205
    // allocation = allocation_box.value.copy()
    dup
    box_get
    pop
    // contract/contract.py:207
    // Global.latest_timestamp > allocation.expires_at
    global LatestTimestamp
    dig 1
    intc_2 // 8
    extract_uint64
    >
    // contract/contract.py:206-208
    // assert (
    //     Global.latest_timestamp > allocation.expires_at
    // ), "Claim period has not ended for this user"
    assert // Claim period has not ended for this user
    // contract/contract.py:210-215
    // # Transfer the user's allocated amount back to the admin
    // itxn.AssetTransfer(
    //     xfer_asset=self.token_id.value,
    //     asset_receiver=self.admin_address.value,
    //     asset_amount=allocation.amount,
    // ).submit()
    itxn_begin
    // contract/contract.py:212
    // xfer_asset=self.token_id.value,
    intc_0 // 0
    bytec_0 // "token_id"
    app_global_get_ex
    assert // check self.token_id exists
    // contract/contract.py:214
    // asset_amount=allocation.amount,
    swap
    intc_0 // 0
    extract_uint64
    itxn_field AssetAmount
    uncover 2
    itxn_field AssetReceiver
    itxn_field XferAsset
    // contract/contract.py:210-211
    // # Transfer the user's allocated amount back to the admin
    // itxn.AssetTransfer(
    intc_3 // axfer
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // contract/contract.py:210-215
    // # Transfer the user's allocated amount back to the admin
    // itxn.AssetTransfer(
    //     xfer_asset=self.token_id.value,
    //     asset_receiver=self.admin_address.value,
    //     asset_amount=allocation.amount,
    // ).submit()
    itxn_submit
    // contract/contract.py:217-218
    // # Delete the allocation
    // del allocation_box.value
    box_del
    pop
    // contract/contract.py:194
    // @arc4.abimethod
    intc_1 // 1
    return
