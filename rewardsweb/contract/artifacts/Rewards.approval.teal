#pragma version 11
#pragma typetrack false

// algopy.arc4.ARC4Contract.approval_program() -> uint64:
main:
    intcblock 0 1 8 32
    bytecblock "token_id" "admin_address" "claim_period_duration" "allocations"
    // contract/contract.py:26
    // class Rewards(arc4.ARC4Contract):
    txn NumAppArgs
    bz main_bare_routing@13
    txn OnCompletion
    !
    assert // OnCompletion must be NoOp
    txn ApplicationID
    assert
    pushbytess 0xb6e5a0e5 0xa7e93504 0xf1577726 0x97892c81 // method "setup(uint64,uint64)void", method "add_allocations(address[],uint64[])void", method "claim()void", method "reclaim_allocation(address)void"
    txna ApplicationArgs 0
    match setup add_allocations claim reclaim_allocation
    err

main_bare_routing@13:
    // contract/contract.py:26
    // class Rewards(arc4.ARC4Contract):
    intc_0 // NoOp
    pushint 5 // DeleteApplication
    txn OnCompletion
    match main_create_application@14 main_delete_application@15
    err

main_delete_application@15:
    // contract/contract.py:69
    // @arc4.baremethod(allow_actions=["DeleteApplication"])
    txn ApplicationID
    assert // can only call when not creating
    // contract/contract.py:74
    // assert Txn.sender == self.admin_address.value, "Sender is not the admin"
    txn Sender
    intc_0 // 0
    bytec_1 // "admin_address"
    app_global_get_ex
    assert // check self.admin_address exists
    ==
    assert // Sender is not the admin
    // contract/contract.py:69
    // @arc4.baremethod(allow_actions=["DeleteApplication"])
    intc_1 // 1
    return

main_create_application@14:
    // contract/contract.py:58
    // @arc4.baremethod(allow_actions=["NoOp"], create="require")
    txn ApplicationID
    !
    assert // can only call when creating
    // contract/contract.py:65
    // self.admin_address.value = Txn.sender
    bytec_1 // "admin_address"
    txn Sender
    app_global_put
    // contract/contract.py:66
    // self.token_id.value = UInt64(0)
    bytec_0 // "token_id"
    intc_0 // 0
    app_global_put
    // contract/contract.py:67
    // self.claim_period_duration.value = UInt64(0)
    bytec_2 // "claim_period_duration"
    intc_0 // 0
    app_global_put
    // contract/contract.py:58
    // @arc4.baremethod(allow_actions=["NoOp"], create="require")
    intc_1 // 1
    return


// contract.contract.Rewards.setup[routing]() -> void:
setup:
    // contract/contract.py:76
    // @arc4.abimethod
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    // contract/contract.py:88
    // assert Txn.sender == self.admin_address.value, "Sender is not the admin"
    txn Sender
    intc_0 // 0
    bytec_1 // "admin_address"
    app_global_get_ex
    assert // check self.admin_address exists
    ==
    assert // Sender is not the admin
    // contract/contract.py:89
    // assert self.token_id.value == 0, "Contract already set up"
    intc_0 // 0
    bytec_0 // "token_id"
    app_global_get_ex
    assert // check self.token_id exists
    !
    assert // Contract already set up
    // contract/contract.py:90
    // self.token_id.value = token.id
    bytec_0 // "token_id"
    uncover 2
    app_global_put
    // contract/contract.py:91
    // self.claim_period_duration.value = claim_period_duration
    bytec_2 // "claim_period_duration"
    swap
    app_global_put
    // contract/contract.py:93-98
    // # Contract opts-in to the ASA
    // itxn.AssetTransfer(
    //     xfer_asset=self.token_id.value,
    //     asset_receiver=Global.current_application_address,
    //     asset_amount=0,
    // ).submit()
    itxn_begin
    // contract/contract.py:95
    // xfer_asset=self.token_id.value,
    intc_0 // 0
    bytec_0 // "token_id"
    app_global_get_ex
    assert // check self.token_id exists
    // contract/contract.py:96
    // asset_receiver=Global.current_application_address,
    global CurrentApplicationAddress
    // contract/contract.py:97
    // asset_amount=0,
    intc_0 // 0
    itxn_field AssetAmount
    itxn_field AssetReceiver
    itxn_field XferAsset
    // contract/contract.py:93-94
    // # Contract opts-in to the ASA
    // itxn.AssetTransfer(
    pushint 4 // axfer
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // contract/contract.py:93-98
    // # Contract opts-in to the ASA
    // itxn.AssetTransfer(
    //     xfer_asset=self.token_id.value,
    //     asset_receiver=Global.current_application_address,
    //     asset_amount=0,
    // ).submit()
    itxn_submit
    // contract/contract.py:76
    // @arc4.abimethod
    intc_1 // 1
    return


// contract.contract.Rewards.add_allocations[routing]() -> void:
add_allocations:
    // contract/contract.py:100
    // @arc4.abimethod
    txna ApplicationArgs 1
    dupn 2
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    dup
    cover 2
    dup
    intc_3 // 32
    *
    pushint 2 // 2
    +
    uncover 2
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.static_array<arc4.uint8, 32>>
    txna ApplicationArgs 2
    dup
    cover 2
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    dup
    intc_2 // 8
    *
    pushint 2 // 2
    +
    uncover 2
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint64>
    // contract/contract.py:116
    // assert Txn.sender == self.admin_address.value, "Sender is not the admin"
    txn Sender
    intc_0 // 0
    bytec_1 // "admin_address"
    app_global_get_ex
    assert // check self.admin_address exists
    ==
    assert // Sender is not the admin
    // contract/contract.py:118
    // addresses.length == amounts.length
    ==
    // contract/contract.py:117-119
    // assert (
    //     addresses.length == amounts.length
    // ), "Input arrays must have the same length"
    assert // Input arrays must have the same length
    // contract/contract.py:121
    // expires_at = Global.latest_timestamp + self.claim_period_duration.value
    global LatestTimestamp
    intc_0 // 0
    bytec_2 // "claim_period_duration"
    app_global_get_ex
    assert // check self.claim_period_duration exists
    +
    // contract/contract.py:122
    // for i in urange(addresses.length):
    intc_0 // 0

add_allocations_for_header@2:
    // contract/contract.py:122
    // for i in urange(addresses.length):
    dup
    dig 4
    <
    bz add_allocations_after_for@8
    // contract/contract.py:123
    // address = addresses[i].native
    dig 4
    extract 2 0
    dig 1
    dup
    cover 2
    intc_3 // 32
    *
    intc_3 // 32
    extract3 // on error: index access is out of bounds
    // contract/contract.py:124
    // amount = amounts[i].as_uint64()
    dig 4
    extract 2 0
    uncover 2
    intc_2 // 8
    *
    extract_uint64
    swap
    // contract/contract.py:125
    // allocation_box = self.allocations.box(address)
    bytec_3 // "allocations"
    swap
    concat
    dup
    cover 2
    // contract/contract.py:126
    // if allocation_box:
    box_len
    bury 1
    bz add_allocations_else_body@5
    // contract/contract.py:127-128
    // # Update existing allocation
    // existing_allocation = allocation_box.value.copy()
    swap
    dup
    box_get
    assert // check Box exists
    // contract/contract.py:129
    // existing_allocation.amount += amount
    dup
    intc_0 // 0
    extract_uint64
    uncover 3
    +
    itob
    replace2 0
    // contract/contract.py:130
    // existing_allocation.expires_at = expires_at
    dig 3
    itob
    replace2 8
    // contract/contract.py:131
    // allocation_box.value = existing_allocation.copy()
    box_put

add_allocations_after_if_else@6:
    // contract/contract.py:122
    // for i in urange(addresses.length):
    dup
    intc_1 // 1
    +
    bury 1
    b add_allocations_for_header@2

add_allocations_else_body@5:
    // contract/contract.py:134-135
    // # Create new allocation
    // assert allocation_box.create()
    swap
    dup
    pushint 16 // 16
    box_create
    assert
    // contract/contract.py:136
    // allocation_box.value = Allocation(amount=amount, expires_at=expires_at)
    swap
    itob
    dig 3
    itob
    concat
    box_put
    b add_allocations_after_if_else@6

add_allocations_after_for@8:
    // contract/contract.py:100
    // @arc4.abimethod
    intc_1 // 1
    return


// contract.contract.Rewards.claim[routing]() -> void:
claim:
    // contract/contract.py:147
    // sender = Txn.sender
    txn Sender
    // contract/contract.py:148
    // allocation_box = self.allocations.box(sender)
    bytec_3 // "allocations"
    dig 1
    concat
    // contract/contract.py:149
    // assert allocation_box, "Sender has no allocation"
    dup
    box_len
    bury 1
    assert // Sender has no allocation
    // contract/contract.py:151
    // allocation = allocation_box.value.copy()
    dup
    box_get
    pop
    // contract/contract.py:153
    // Global.latest_timestamp <= allocation.expires_at
    global LatestTimestamp
    dig 1
    intc_2 // 8
    extract_uint64
    <=
    // contract/contract.py:152-154
    // assert (
    //     Global.latest_timestamp <= allocation.expires_at
    // ), "Claim period has ended"
    assert // Claim period has ended
    // contract/contract.py:156
    // amount_to_claim = allocation.amount
    intc_0 // 0
    extract_uint64
    // contract/contract.py:160
    // sender, self.token_id.value
    intc_0 // 0
    bytec_0 // "token_id"
    app_global_get_ex
    assert // check self.token_id exists
    // contract/contract.py:158-161
    // # Check if the user is already opted-in to the asset
    // balance, opted_in = op.AssetHoldingGet.asset_balance(
    //     sender, self.token_id.value
    // )
    dig 3
    dig 1
    asset_holding_get AssetBalance
    bury 1
    // contract/contract.py:162
    // assert opted_in, "Sender has not opted-in to the asset"
    assert // Sender has not opted-in to the asset
    // contract/contract.py:164-169
    // # Create the transaction to transfer the allocated amount
    // itxn.AssetTransfer(
    //     xfer_asset=self.token_id.value,
    //     asset_receiver=sender,
    //     asset_amount=amount_to_claim,
    // ).submit()
    itxn_begin
    swap
    itxn_field AssetAmount
    uncover 2
    itxn_field AssetReceiver
    itxn_field XferAsset
    // contract/contract.py:164-165
    // # Create the transaction to transfer the allocated amount
    // itxn.AssetTransfer(
    pushint 4 // axfer
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // contract/contract.py:164-169
    // # Create the transaction to transfer the allocated amount
    // itxn.AssetTransfer(
    //     xfer_asset=self.token_id.value,
    //     asset_receiver=sender,
    //     asset_amount=amount_to_claim,
    // ).submit()
    itxn_submit
    // contract/contract.py:171-172
    // # Delete the allocation to prevent claiming again
    // del allocation_box.value
    box_del
    pop
    // contract/contract.py:138
    // @arc4.abimethod(name="claim")
    intc_1 // 1
    return


// contract.contract.Rewards.reclaim_allocation[routing]() -> void:
reclaim_allocation:
    // contract/contract.py:174
    // @arc4.abimethod
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 32
    ==
    assert // invalid number of bytes for arc4.static_array<arc4.uint8, 32>
    // contract/contract.py:182
    // assert Txn.sender == self.admin_address.value, "Sender is not the admin"
    txn Sender
    intc_0 // 0
    bytec_1 // "admin_address"
    app_global_get_ex
    assert // check self.admin_address exists
    swap
    dig 1
    ==
    assert // Sender is not the admin
    // contract/contract.py:183
    // allocation_box = self.allocations.box(user_address)
    bytec_3 // "allocations"
    uncover 2
    concat
    // contract/contract.py:184
    // assert allocation_box, "User has no allocation"
    dup
    box_len
    bury 1
    assert // User has no allocation
    // contract/contract.py:185
    // allocation = allocation_box.value.copy()
    dup
    box_get
    pop
    // contract/contract.py:187
    // Global.latest_timestamp > allocation.expires_at
    global LatestTimestamp
    dig 1
    intc_2 // 8
    extract_uint64
    >
    // contract/contract.py:186-188
    // assert (
    //     Global.latest_timestamp > allocation.expires_at
    // ), "Claim period has not ended for this user"
    assert // Claim period has not ended for this user
    // contract/contract.py:190-195
    // # Transfer the user's allocated amount back to the admin
    // itxn.AssetTransfer(
    //     xfer_asset=self.token_id.value,
    //     asset_receiver=self.admin_address.value,
    //     asset_amount=allocation.amount,
    // ).submit()
    itxn_begin
    // contract/contract.py:192
    // xfer_asset=self.token_id.value,
    intc_0 // 0
    bytec_0 // "token_id"
    app_global_get_ex
    assert // check self.token_id exists
    // contract/contract.py:194
    // asset_amount=allocation.amount,
    swap
    intc_0 // 0
    extract_uint64
    itxn_field AssetAmount
    uncover 2
    itxn_field AssetReceiver
    itxn_field XferAsset
    // contract/contract.py:190-191
    // # Transfer the user's allocated amount back to the admin
    // itxn.AssetTransfer(
    pushint 4 // axfer
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // contract/contract.py:190-195
    // # Transfer the user's allocated amount back to the admin
    // itxn.AssetTransfer(
    //     xfer_asset=self.token_id.value,
    //     asset_receiver=self.admin_address.value,
    //     asset_amount=allocation.amount,
    // ).submit()
    itxn_submit
    // contract/contract.py:197-198
    // # Delete the allocation
    // del allocation_box.value
    box_del
    pop
    // contract/contract.py:174
    // @arc4.abimethod
    intc_1 // 1
    return
